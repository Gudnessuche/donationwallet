// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.37.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../constants.dart';
import '../frb_generated.dart';
import '../logger.dart';
import '../stream.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Stream<LogEntry> createLogStream(
        {required LogLevel level, required bool logDependencies}) =>
    RustLib.instance.api.crateApiSimpleCreateLogStream(
        level: level, logDependencies: logDependencies);

Stream<SyncStatus> createSyncStream() =>
    RustLib.instance.api.crateApiSimpleCreateSyncStream();

Stream<ScanProgress> createScanProgressStream() =>
    RustLib.instance.api.crateApiSimpleCreateScanProgressStream();

Stream<BigInt> createAmountStream() =>
    RustLib.instance.api.crateApiSimpleCreateAmountStream();

Future<bool> walletExists({required String label, required String filesDir}) =>
    RustLib.instance.api
        .crateApiSimpleWalletExists(label: label, filesDir: filesDir);

Future<String> setup(
        {required String label,
        required String filesDir,
        required WalletType walletType,
        required int birthday,
        required bool isTestnet}) =>
    RustLib.instance.api.crateApiSimpleSetup(
        label: label,
        filesDir: filesDir,
        walletType: walletType,
        birthday: birthday,
        isTestnet: isTestnet);

/// Change wallet birthday
/// Since this method doesn't touch the known outputs
/// the caller is responsible for resetting the wallet to its new birthday
Future<void> changeBirthday(
        {required String path, required String label, required int birthday}) =>
    RustLib.instance.api.crateApiSimpleChangeBirthday(
        path: path, label: label, birthday: birthday);

/// Reset the last_scan of the wallet to its birthday, removing all outpoints
Future<void> resetWallet({required String path, required String label}) =>
    RustLib.instance.api.crateApiSimpleResetWallet(path: path, label: label);

Future<void> removeWallet({required String path, required String label}) =>
    RustLib.instance.api.crateApiSimpleRemoveWallet(path: path, label: label);

Future<void> syncBlockchain() =>
    RustLib.instance.api.crateApiSimpleSyncBlockchain();

Future<void> scanToTip({required String path, required String label}) =>
    RustLib.instance.api.crateApiSimpleScanToTip(path: path, label: label);

Future<WalletStatus> getWalletInfo(
        {required String path, required String label}) =>
    RustLib.instance.api.crateApiSimpleGetWalletInfo(path: path, label: label);

Future<String> getReceivingAddress(
        {required String path, required String label}) =>
    RustLib.instance.api
        .crateApiSimpleGetReceivingAddress(path: path, label: label);

Future<List<OwnedOutput>> getSpendableOutputs(
        {required String path, required String label}) =>
    RustLib.instance.api
        .crateApiSimpleGetSpendableOutputs(path: path, label: label);

Future<List<OwnedOutput>> getOutputs(
        {required String path, required String label}) =>
    RustLib.instance.api.crateApiSimpleGetOutputs(path: path, label: label);

Future<String> createNewPsbt(
        {required String label,
        required String path,
        required List<OwnedOutput> inputs,
        required List<Recipient> recipients}) =>
    RustLib.instance.api.crateApiSimpleCreateNewPsbt(
        label: label, path: path, inputs: inputs, recipients: recipients);

Future<String> addFeeForFeeRate(
        {required String psbt, required int feeRate, required String payer}) =>
    RustLib.instance.api.crateApiSimpleAddFeeForFeeRate(
        psbt: psbt, feeRate: feeRate, payer: payer);

Future<String> fillSpOutputs(
        {required String path, required String label, required String psbt}) =>
    RustLib.instance.api
        .crateApiSimpleFillSpOutputs(path: path, label: label, psbt: psbt);

Future<String> signPsbt(
        {required String path,
        required String label,
        required String psbt,
        required bool finalize}) =>
    RustLib.instance.api.crateApiSimpleSignPsbt(
        path: path, label: label, psbt: psbt, finalize: finalize);

Future<String> extractTxFromPsbt({required String psbt}) =>
    RustLib.instance.api.crateApiSimpleExtractTxFromPsbt(psbt: psbt);

Future<String> broadcastTx({required String tx}) =>
    RustLib.instance.api.crateApiSimpleBroadcastTx(tx: tx);

Future<void> markTransactionInputsAsSpent(
        {required String path, required String label, required String tx}) =>
    RustLib.instance.api.crateApiSimpleMarkTransactionInputsAsSpent(
        path: path, label: label, tx: tx);

Future<String?> showMnemonic({required String path, required String label}) =>
    RustLib.instance.api.crateApiSimpleShowMnemonic(path: path, label: label);

class WalletStatus {
  final BigInt amount;
  final int birthday;
  final int scanHeight;

  const WalletStatus({
    required this.amount,
    required this.birthday,
    required this.scanHeight,
  });

  @override
  int get hashCode => amount.hashCode ^ birthday.hashCode ^ scanHeight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WalletStatus &&
          runtimeType == other.runtimeType &&
          amount == other.amount &&
          birthday == other.birthday &&
          scanHeight == other.scanHeight;
}
