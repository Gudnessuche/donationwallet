// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.37.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../logger.dart';
import '../stream.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'simple.freezed.dart';

// The functions `fmt`, `clone`, `eq`, `from`, `from`, `fmt`, `clone`, `eq`, `from`, `from`, `fmt`, `clone`, `eq`, `from`, `from`, `fmt`, `clone`, `eq`, `from`, `from` are not `pub`, thus are ignored.

Stream<LogEntry> createLogStream(
        {required LogLevel level, required bool logDependencies}) =>
    RustLib.instance.api.crateApiSimpleCreateLogStream(
        level: level, logDependencies: logDependencies);

Stream<SyncStatus> createSyncStream() =>
    RustLib.instance.api.crateApiSimpleCreateSyncStream();

Stream<ScanProgress> createScanProgressStream() =>
    RustLib.instance.api.crateApiSimpleCreateScanProgressStream();

Stream<BigInt> createAmountStream() =>
    RustLib.instance.api.crateApiSimpleCreateAmountStream();

bool walletExists({required String label, required String filesDir}) =>
    RustLib.instance.api
        .crateApiSimpleWalletExists(label: label, filesDir: filesDir);

Future<void> setup(
        {required String label,
        required String filesDir,
        required WalletType walletType,
        required int birthday,
        required bool isTestnet}) =>
    RustLib.instance.api.crateApiSimpleSetup(
        label: label,
        filesDir: filesDir,
        walletType: walletType,
        birthday: birthday,
        isTestnet: isTestnet);

/// Change wallet birthday
/// Reset the output list and last_scan
Future<void> changeBirthday(
        {required String path, required String label, required int birthday}) =>
    RustLib.instance.api.crateApiSimpleChangeBirthday(
        path: path, label: label, birthday: birthday);

/// Reset the last_scan of the wallet to its birthday, removing all outpoints
Future<void> resetWallet({required String path, required String label}) =>
    RustLib.instance.api.crateApiSimpleResetWallet(path: path, label: label);

void removeWallet({required String path, required String label}) =>
    RustLib.instance.api.crateApiSimpleRemoveWallet(path: path, label: label);

Future<void> syncBlockchain() =>
    RustLib.instance.api.crateApiSimpleSyncBlockchain();

Future<void> scanToTip({required String path, required String label}) =>
    RustLib.instance.api.crateApiSimpleScanToTip(path: path, label: label);

WalletStatus getWalletInfo({required String path, required String label}) =>
    RustLib.instance.api.crateApiSimpleGetWalletInfo(path: path, label: label);

String getReceivingAddress({required String path, required String label}) =>
    RustLib.instance.api
        .crateApiSimpleGetReceivingAddress(path: path, label: label);

List<(String, OwnedOutput)> getSpendableOutputs(
        {required String path, required String label}) =>
    RustLib.instance.api
        .crateApiSimpleGetSpendableOutputs(path: path, label: label);

Map<String, OwnedOutput> getOutputs(
        {required String path, required String label}) =>
    RustLib.instance.api.crateApiSimpleGetOutputs(path: path, label: label);

String createNewPsbt(
        {required String label,
        required String path,
        required Map<String, OwnedOutput> inputs,
        required List<Recipient> recipients}) =>
    RustLib.instance.api.crateApiSimpleCreateNewPsbt(
        label: label, path: path, inputs: inputs, recipients: recipients);

Future<String> addFeeForFeeRate(
        {required String psbt, required int feeRate, required String payer}) =>
    RustLib.instance.api.crateApiSimpleAddFeeForFeeRate(
        psbt: psbt, feeRate: feeRate, payer: payer);

Future<String> fillSpOutputs(
        {required String path, required String label, required String psbt}) =>
    RustLib.instance.api
        .crateApiSimpleFillSpOutputs(path: path, label: label, psbt: psbt);

String signPsbt(
        {required String path,
        required String label,
        required String psbt,
        required bool finalize}) =>
    RustLib.instance.api.crateApiSimpleSignPsbt(
        path: path, label: label, psbt: psbt, finalize: finalize);

Future<String> extractTxFromPsbt({required String psbt}) =>
    RustLib.instance.api.crateApiSimpleExtractTxFromPsbt(psbt: psbt);

Future<String> broadcastTx({required String tx}) =>
    RustLib.instance.api.crateApiSimpleBroadcastTx(tx: tx);

void markOutpointSpent(
        {required String path,
        required String label,
        required String outpoint,
        required String txid}) =>
    RustLib.instance.api.crateApiSimpleMarkOutpointSpent(
        path: path, label: label, outpoint: outpoint, txid: txid);

Future<String?> showMnemonic({required String path, required String label}) =>
    RustLib.instance.api.crateApiSimpleShowMnemonic(path: path, label: label);

class Amount {
  final BigInt field0;

  const Amount({
    required this.field0,
  });

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Amount &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

@freezed
sealed class OutputSpendStatus with _$OutputSpendStatus {
  const OutputSpendStatus._();

  const factory OutputSpendStatus.unspent() = OutputSpendStatus_Unspent;
  const factory OutputSpendStatus.spent(
    String field0,
  ) = OutputSpendStatus_Spent;
  const factory OutputSpendStatus.mined(
    String field0,
  ) = OutputSpendStatus_Mined;
}

class OwnedOutput {
  final int blockheight;
  final String tweak;
  final Amount amount;
  final String script;
  final String? label;
  final OutputSpendStatus spendStatus;

  const OwnedOutput({
    required this.blockheight,
    required this.tweak,
    required this.amount,
    required this.script,
    this.label,
    required this.spendStatus,
  });

  @override
  int get hashCode =>
      blockheight.hashCode ^
      tweak.hashCode ^
      amount.hashCode ^
      script.hashCode ^
      label.hashCode ^
      spendStatus.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OwnedOutput &&
          runtimeType == other.runtimeType &&
          blockheight == other.blockheight &&
          tweak == other.tweak &&
          amount == other.amount &&
          script == other.script &&
          label == other.label &&
          spendStatus == other.spendStatus;
}

class Recipient {
  final String address;
  final Amount amount;
  final int nbOutputs;

  const Recipient({
    required this.address,
    required this.amount,
    required this.nbOutputs,
  });

  @override
  int get hashCode => address.hashCode ^ amount.hashCode ^ nbOutputs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Recipient &&
          runtimeType == other.runtimeType &&
          address == other.address &&
          amount == other.amount &&
          nbOutputs == other.nbOutputs;
}

class WalletStatus {
  final BigInt amount;
  final int birthday;
  final int scanHeight;

  const WalletStatus({
    required this.amount,
    required this.birthday,
    required this.scanHeight,
  });

  @override
  int get hashCode => amount.hashCode ^ birthday.hashCode ^ scanHeight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WalletStatus &&
          runtimeType == other.runtimeType &&
          amount == other.amount &&
          birthday == other.birthday &&
          scanHeight == other.scanHeight;
}

@freezed
sealed class WalletType with _$WalletType {
  const WalletType._();

  const factory WalletType.new() = WalletType_New;
  const factory WalletType.mnemonic(
    String field0,
  ) = WalletType_Mnemonic;
  const factory WalletType.privateKeys(
    String field0,
    String field1,
  ) = WalletType_PrivateKeys;
  const factory WalletType.watchOnly(
    String field0,
    String field1,
  ) = WalletType_WatchOnly;
}
