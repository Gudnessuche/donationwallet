// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'simple.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;


final _privateConstructorUsedError = UnsupportedError('It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$OutputSpendStatus {


@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  unspent,required TResult Function( String field0)  spent,required TResult Function( String field0)  mined,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  unspent,TResult? Function( String field0)?  spent,TResult? Function( String field0)?  mined,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  unspent,TResult Function( String field0)?  spent,TResult Function( String field0)?  mined,required TResult orElse(),}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( OutputSpendStatus_Unspent value)  unspent,required TResult Function( OutputSpendStatus_Spent value)  spent,required TResult Function( OutputSpendStatus_Mined value)  mined,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( OutputSpendStatus_Unspent value)?  unspent,TResult? Function( OutputSpendStatus_Spent value)?  spent,TResult? Function( OutputSpendStatus_Mined value)?  mined,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( OutputSpendStatus_Unspent value)?  unspent,TResult Function( OutputSpendStatus_Spent value)?  spent,TResult Function( OutputSpendStatus_Mined value)?  mined,required TResult orElse(),}) => throw _privateConstructorUsedError;


}

/// @nodoc
abstract class $OutputSpendStatusCopyWith<$Res>  {
  factory $OutputSpendStatusCopyWith(OutputSpendStatus value, $Res Function(OutputSpendStatus) then) = _$OutputSpendStatusCopyWithImpl<$Res, OutputSpendStatus>;



}

/// @nodoc
class _$OutputSpendStatusCopyWithImpl<$Res,$Val extends OutputSpendStatus> implements $OutputSpendStatusCopyWith<$Res> {
  _$OutputSpendStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;



}


/// @nodoc
abstract class _$$OutputSpendStatus_UnspentImplCopyWith<$Res>  {
  factory _$$OutputSpendStatus_UnspentImplCopyWith(_$OutputSpendStatus_UnspentImpl value, $Res Function(_$OutputSpendStatus_UnspentImpl) then) = __$$OutputSpendStatus_UnspentImplCopyWithImpl<$Res>;



}

/// @nodoc
class __$$OutputSpendStatus_UnspentImplCopyWithImpl<$Res> extends _$OutputSpendStatusCopyWithImpl<$Res, _$OutputSpendStatus_UnspentImpl> implements _$$OutputSpendStatus_UnspentImplCopyWith<$Res> {
  __$$OutputSpendStatus_UnspentImplCopyWithImpl(_$OutputSpendStatus_UnspentImpl _value, $Res Function(_$OutputSpendStatus_UnspentImpl) _then)
      : super(_value, _then);





}

/// @nodoc


class _$OutputSpendStatus_UnspentImpl extends OutputSpendStatus_Unspent  {
  const _$OutputSpendStatus_UnspentImpl(): super._();

  



@override
String toString() {
  return 'OutputSpendStatus.unspent()';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$OutputSpendStatus_UnspentImpl);
}


@override
int get hashCode => runtimeType.hashCode;


@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  unspent,required TResult Function( String field0)  spent,required TResult Function( String field0)  mined,}) {
  return unspent();
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  unspent,TResult? Function( String field0)?  spent,TResult? Function( String field0)?  mined,}) {
  return unspent?.call();
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  unspent,TResult Function( String field0)?  spent,TResult Function( String field0)?  mined,required TResult orElse(),}) {
  if (unspent != null) {
    return unspent();
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( OutputSpendStatus_Unspent value)  unspent,required TResult Function( OutputSpendStatus_Spent value)  spent,required TResult Function( OutputSpendStatus_Mined value)  mined,}) {
  return unspent(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( OutputSpendStatus_Unspent value)?  unspent,TResult? Function( OutputSpendStatus_Spent value)?  spent,TResult? Function( OutputSpendStatus_Mined value)?  mined,}) {
  return unspent?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( OutputSpendStatus_Unspent value)?  unspent,TResult Function( OutputSpendStatus_Spent value)?  spent,TResult Function( OutputSpendStatus_Mined value)?  mined,required TResult orElse(),}) {
  if (unspent != null) {
    return unspent(this);
  }
  return orElse();
}

}


abstract class OutputSpendStatus_Unspent extends OutputSpendStatus {
  const factory OutputSpendStatus_Unspent() = _$OutputSpendStatus_UnspentImpl;
  const OutputSpendStatus_Unspent._(): super._();

  



}

/// @nodoc
abstract class _$$OutputSpendStatus_SpentImplCopyWith<$Res>  {
  factory _$$OutputSpendStatus_SpentImplCopyWith(_$OutputSpendStatus_SpentImpl value, $Res Function(_$OutputSpendStatus_SpentImpl) then) = __$$OutputSpendStatus_SpentImplCopyWithImpl<$Res>;
@useResult
$Res call({
 String field0
});



}

/// @nodoc
class __$$OutputSpendStatus_SpentImplCopyWithImpl<$Res> extends _$OutputSpendStatusCopyWithImpl<$Res, _$OutputSpendStatus_SpentImpl> implements _$$OutputSpendStatus_SpentImplCopyWith<$Res> {
  __$$OutputSpendStatus_SpentImplCopyWithImpl(_$OutputSpendStatus_SpentImpl _value, $Res Function(_$OutputSpendStatus_SpentImpl) _then)
      : super(_value, _then);


@pragma('vm:prefer-inline') @override $Res call({Object? field0 = null,}) {
  return _then(_$OutputSpendStatus_SpentImpl(
null == field0 ? _value.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class _$OutputSpendStatus_SpentImpl extends OutputSpendStatus_Spent  {
  const _$OutputSpendStatus_SpentImpl(this.field0): super._();

  

@override final  String field0;

@override
String toString() {
  return 'OutputSpendStatus.spent(field0: $field0)';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$OutputSpendStatus_SpentImpl&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@JsonKey(ignore: true)
@override
@pragma('vm:prefer-inline')
_$$OutputSpendStatus_SpentImplCopyWith<_$OutputSpendStatus_SpentImpl> get copyWith => __$$OutputSpendStatus_SpentImplCopyWithImpl<_$OutputSpendStatus_SpentImpl>(this, _$identity);

@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  unspent,required TResult Function( String field0)  spent,required TResult Function( String field0)  mined,}) {
  return spent(field0);
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  unspent,TResult? Function( String field0)?  spent,TResult? Function( String field0)?  mined,}) {
  return spent?.call(field0);
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  unspent,TResult Function( String field0)?  spent,TResult Function( String field0)?  mined,required TResult orElse(),}) {
  if (spent != null) {
    return spent(field0);
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( OutputSpendStatus_Unspent value)  unspent,required TResult Function( OutputSpendStatus_Spent value)  spent,required TResult Function( OutputSpendStatus_Mined value)  mined,}) {
  return spent(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( OutputSpendStatus_Unspent value)?  unspent,TResult? Function( OutputSpendStatus_Spent value)?  spent,TResult? Function( OutputSpendStatus_Mined value)?  mined,}) {
  return spent?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( OutputSpendStatus_Unspent value)?  unspent,TResult Function( OutputSpendStatus_Spent value)?  spent,TResult Function( OutputSpendStatus_Mined value)?  mined,required TResult orElse(),}) {
  if (spent != null) {
    return spent(this);
  }
  return orElse();
}

}


abstract class OutputSpendStatus_Spent extends OutputSpendStatus {
  const factory OutputSpendStatus_Spent(final  String field0) = _$OutputSpendStatus_SpentImpl;
  const OutputSpendStatus_Spent._(): super._();

  

 String get field0;
@JsonKey(ignore: true)
_$$OutputSpendStatus_SpentImplCopyWith<_$OutputSpendStatus_SpentImpl> get copyWith => throw _privateConstructorUsedError;

}

/// @nodoc
abstract class _$$OutputSpendStatus_MinedImplCopyWith<$Res>  {
  factory _$$OutputSpendStatus_MinedImplCopyWith(_$OutputSpendStatus_MinedImpl value, $Res Function(_$OutputSpendStatus_MinedImpl) then) = __$$OutputSpendStatus_MinedImplCopyWithImpl<$Res>;
@useResult
$Res call({
 String field0
});



}

/// @nodoc
class __$$OutputSpendStatus_MinedImplCopyWithImpl<$Res> extends _$OutputSpendStatusCopyWithImpl<$Res, _$OutputSpendStatus_MinedImpl> implements _$$OutputSpendStatus_MinedImplCopyWith<$Res> {
  __$$OutputSpendStatus_MinedImplCopyWithImpl(_$OutputSpendStatus_MinedImpl _value, $Res Function(_$OutputSpendStatus_MinedImpl) _then)
      : super(_value, _then);


@pragma('vm:prefer-inline') @override $Res call({Object? field0 = null,}) {
  return _then(_$OutputSpendStatus_MinedImpl(
null == field0 ? _value.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class _$OutputSpendStatus_MinedImpl extends OutputSpendStatus_Mined  {
  const _$OutputSpendStatus_MinedImpl(this.field0): super._();

  

@override final  String field0;

@override
String toString() {
  return 'OutputSpendStatus.mined(field0: $field0)';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$OutputSpendStatus_MinedImpl&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@JsonKey(ignore: true)
@override
@pragma('vm:prefer-inline')
_$$OutputSpendStatus_MinedImplCopyWith<_$OutputSpendStatus_MinedImpl> get copyWith => __$$OutputSpendStatus_MinedImplCopyWithImpl<_$OutputSpendStatus_MinedImpl>(this, _$identity);

@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  unspent,required TResult Function( String field0)  spent,required TResult Function( String field0)  mined,}) {
  return mined(field0);
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  unspent,TResult? Function( String field0)?  spent,TResult? Function( String field0)?  mined,}) {
  return mined?.call(field0);
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  unspent,TResult Function( String field0)?  spent,TResult Function( String field0)?  mined,required TResult orElse(),}) {
  if (mined != null) {
    return mined(field0);
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( OutputSpendStatus_Unspent value)  unspent,required TResult Function( OutputSpendStatus_Spent value)  spent,required TResult Function( OutputSpendStatus_Mined value)  mined,}) {
  return mined(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( OutputSpendStatus_Unspent value)?  unspent,TResult? Function( OutputSpendStatus_Spent value)?  spent,TResult? Function( OutputSpendStatus_Mined value)?  mined,}) {
  return mined?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( OutputSpendStatus_Unspent value)?  unspent,TResult Function( OutputSpendStatus_Spent value)?  spent,TResult Function( OutputSpendStatus_Mined value)?  mined,required TResult orElse(),}) {
  if (mined != null) {
    return mined(this);
  }
  return orElse();
}

}


abstract class OutputSpendStatus_Mined extends OutputSpendStatus {
  const factory OutputSpendStatus_Mined(final  String field0) = _$OutputSpendStatus_MinedImpl;
  const OutputSpendStatus_Mined._(): super._();

  

 String get field0;
@JsonKey(ignore: true)
_$$OutputSpendStatus_MinedImplCopyWith<_$OutputSpendStatus_MinedImpl> get copyWith => throw _privateConstructorUsedError;

}

/// @nodoc
mixin _$WalletType {


@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function()  new,{required TResult Function( String field0)  mnemonic,required TResult Function( String field0,  String field1)  privateKeys,required TResult Function( String field0,  String field1)  watchOnly,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function()?  new,{TResult? Function( String field0)?  mnemonic,TResult? Function( String field0,  String field1)?  privateKeys,TResult? Function( String field0,  String field1)?  watchOnly,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function()?  new,{TResult Function( String field0)?  mnemonic,TResult Function( String field0,  String field1)?  privateKeys,TResult Function( String field0,  String field1)?  watchOnly,required TResult orElse(),}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( WalletType_New value)  new,{required TResult Function( WalletType_Mnemonic value)  mnemonic,required TResult Function( WalletType_PrivateKeys value)  privateKeys,required TResult Function( WalletType_WatchOnly value)  watchOnly,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( WalletType_New value)?  new,{TResult? Function( WalletType_Mnemonic value)?  mnemonic,TResult? Function( WalletType_PrivateKeys value)?  privateKeys,TResult? Function( WalletType_WatchOnly value)?  watchOnly,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( WalletType_New value)?  new,{TResult Function( WalletType_Mnemonic value)?  mnemonic,TResult Function( WalletType_PrivateKeys value)?  privateKeys,TResult Function( WalletType_WatchOnly value)?  watchOnly,required TResult orElse(),}) => throw _privateConstructorUsedError;


}

/// @nodoc
abstract class $WalletTypeCopyWith<$Res>  {
  factory $WalletTypeCopyWith(WalletType value, $Res Function(WalletType) then) = _$WalletTypeCopyWithImpl<$Res, WalletType>;



}

/// @nodoc
class _$WalletTypeCopyWithImpl<$Res,$Val extends WalletType> implements $WalletTypeCopyWith<$Res> {
  _$WalletTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;



}


/// @nodoc
abstract class _$$WalletType_NewImplCopyWith<$Res>  {
  factory _$$WalletType_NewImplCopyWith(_$WalletType_NewImpl value, $Res Function(_$WalletType_NewImpl) then) = __$$WalletType_NewImplCopyWithImpl<$Res>;



}

/// @nodoc
class __$$WalletType_NewImplCopyWithImpl<$Res> extends _$WalletTypeCopyWithImpl<$Res, _$WalletType_NewImpl> implements _$$WalletType_NewImplCopyWith<$Res> {
  __$$WalletType_NewImplCopyWithImpl(_$WalletType_NewImpl _value, $Res Function(_$WalletType_NewImpl) _then)
      : super(_value, _then);





}

/// @nodoc


class _$WalletType_NewImpl extends WalletType_New  {
  const _$WalletType_NewImpl(): super._();

  



@override
String toString() {
  return 'WalletType.new()';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$WalletType_NewImpl);
}


@override
int get hashCode => runtimeType.hashCode;


@override
@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function()  new,{required TResult Function( String field0)  mnemonic,required TResult Function( String field0,  String field1)  privateKeys,required TResult Function( String field0,  String field1)  watchOnly,}) {
  return new();
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function()?  new,{TResult? Function( String field0)?  mnemonic,TResult? Function( String field0,  String field1)?  privateKeys,TResult? Function( String field0,  String field1)?  watchOnly,}) {
  return new?.call();
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function()?  new,{TResult Function( String field0)?  mnemonic,TResult Function( String field0,  String field1)?  privateKeys,TResult Function( String field0,  String field1)?  watchOnly,required TResult orElse(),}) {
  if (new != null) {
    return new();
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( WalletType_New value)  new,{required TResult Function( WalletType_Mnemonic value)  mnemonic,required TResult Function( WalletType_PrivateKeys value)  privateKeys,required TResult Function( WalletType_WatchOnly value)  watchOnly,}) {
  return new(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( WalletType_New value)?  new,{TResult? Function( WalletType_Mnemonic value)?  mnemonic,TResult? Function( WalletType_PrivateKeys value)?  privateKeys,TResult? Function( WalletType_WatchOnly value)?  watchOnly,}) {
  return new?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( WalletType_New value)?  new,{TResult Function( WalletType_Mnemonic value)?  mnemonic,TResult Function( WalletType_PrivateKeys value)?  privateKeys,TResult Function( WalletType_WatchOnly value)?  watchOnly,required TResult orElse(),}) {
  if (new != null) {
    return new(this);
  }
  return orElse();
}

}


abstract class WalletType_New extends WalletType {
  const factory WalletType_New() = _$WalletType_NewImpl;
  const WalletType_New._(): super._();

  



}

/// @nodoc
abstract class _$$WalletType_MnemonicImplCopyWith<$Res>  {
  factory _$$WalletType_MnemonicImplCopyWith(_$WalletType_MnemonicImpl value, $Res Function(_$WalletType_MnemonicImpl) then) = __$$WalletType_MnemonicImplCopyWithImpl<$Res>;
@useResult
$Res call({
 String field0
});



}

/// @nodoc
class __$$WalletType_MnemonicImplCopyWithImpl<$Res> extends _$WalletTypeCopyWithImpl<$Res, _$WalletType_MnemonicImpl> implements _$$WalletType_MnemonicImplCopyWith<$Res> {
  __$$WalletType_MnemonicImplCopyWithImpl(_$WalletType_MnemonicImpl _value, $Res Function(_$WalletType_MnemonicImpl) _then)
      : super(_value, _then);


@pragma('vm:prefer-inline') @override $Res call({Object? field0 = null,}) {
  return _then(_$WalletType_MnemonicImpl(
null == field0 ? _value.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class _$WalletType_MnemonicImpl extends WalletType_Mnemonic  {
  const _$WalletType_MnemonicImpl(this.field0): super._();

  

@override final  String field0;

@override
String toString() {
  return 'WalletType.mnemonic(field0: $field0)';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$WalletType_MnemonicImpl&&(identical(other.field0, field0) || other.field0 == field0));
}


@override
int get hashCode => Object.hash(runtimeType,field0);

@JsonKey(ignore: true)
@override
@pragma('vm:prefer-inline')
_$$WalletType_MnemonicImplCopyWith<_$WalletType_MnemonicImpl> get copyWith => __$$WalletType_MnemonicImplCopyWithImpl<_$WalletType_MnemonicImpl>(this, _$identity);

@override
@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function()  new,{required TResult Function( String field0)  mnemonic,required TResult Function( String field0,  String field1)  privateKeys,required TResult Function( String field0,  String field1)  watchOnly,}) {
  return mnemonic(field0);
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function()?  new,{TResult? Function( String field0)?  mnemonic,TResult? Function( String field0,  String field1)?  privateKeys,TResult? Function( String field0,  String field1)?  watchOnly,}) {
  return mnemonic?.call(field0);
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function()?  new,{TResult Function( String field0)?  mnemonic,TResult Function( String field0,  String field1)?  privateKeys,TResult Function( String field0,  String field1)?  watchOnly,required TResult orElse(),}) {
  if (mnemonic != null) {
    return mnemonic(field0);
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( WalletType_New value)  new,{required TResult Function( WalletType_Mnemonic value)  mnemonic,required TResult Function( WalletType_PrivateKeys value)  privateKeys,required TResult Function( WalletType_WatchOnly value)  watchOnly,}) {
  return mnemonic(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( WalletType_New value)?  new,{TResult? Function( WalletType_Mnemonic value)?  mnemonic,TResult? Function( WalletType_PrivateKeys value)?  privateKeys,TResult? Function( WalletType_WatchOnly value)?  watchOnly,}) {
  return mnemonic?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( WalletType_New value)?  new,{TResult Function( WalletType_Mnemonic value)?  mnemonic,TResult Function( WalletType_PrivateKeys value)?  privateKeys,TResult Function( WalletType_WatchOnly value)?  watchOnly,required TResult orElse(),}) {
  if (mnemonic != null) {
    return mnemonic(this);
  }
  return orElse();
}

}


abstract class WalletType_Mnemonic extends WalletType {
  const factory WalletType_Mnemonic(final  String field0) = _$WalletType_MnemonicImpl;
  const WalletType_Mnemonic._(): super._();

  

 String get field0;
@JsonKey(ignore: true)
_$$WalletType_MnemonicImplCopyWith<_$WalletType_MnemonicImpl> get copyWith => throw _privateConstructorUsedError;

}

/// @nodoc
abstract class _$$WalletType_PrivateKeysImplCopyWith<$Res>  {
  factory _$$WalletType_PrivateKeysImplCopyWith(_$WalletType_PrivateKeysImpl value, $Res Function(_$WalletType_PrivateKeysImpl) then) = __$$WalletType_PrivateKeysImplCopyWithImpl<$Res>;
@useResult
$Res call({
 String field0, String field1
});



}

/// @nodoc
class __$$WalletType_PrivateKeysImplCopyWithImpl<$Res> extends _$WalletTypeCopyWithImpl<$Res, _$WalletType_PrivateKeysImpl> implements _$$WalletType_PrivateKeysImplCopyWith<$Res> {
  __$$WalletType_PrivateKeysImplCopyWithImpl(_$WalletType_PrivateKeysImpl _value, $Res Function(_$WalletType_PrivateKeysImpl) _then)
      : super(_value, _then);


@pragma('vm:prefer-inline') @override $Res call({Object? field0 = null,Object? field1 = null,}) {
  return _then(_$WalletType_PrivateKeysImpl(
null == field0 ? _value.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,null == field1 ? _value.field1 : field1 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class _$WalletType_PrivateKeysImpl extends WalletType_PrivateKeys  {
  const _$WalletType_PrivateKeysImpl(this.field0, this.field1): super._();

  

@override final  String field0;
@override final  String field1;

@override
String toString() {
  return 'WalletType.privateKeys(field0: $field0, field1: $field1)';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$WalletType_PrivateKeysImpl&&(identical(other.field0, field0) || other.field0 == field0)&&(identical(other.field1, field1) || other.field1 == field1));
}


@override
int get hashCode => Object.hash(runtimeType,field0,field1);

@JsonKey(ignore: true)
@override
@pragma('vm:prefer-inline')
_$$WalletType_PrivateKeysImplCopyWith<_$WalletType_PrivateKeysImpl> get copyWith => __$$WalletType_PrivateKeysImplCopyWithImpl<_$WalletType_PrivateKeysImpl>(this, _$identity);

@override
@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function()  new,{required TResult Function( String field0)  mnemonic,required TResult Function( String field0,  String field1)  privateKeys,required TResult Function( String field0,  String field1)  watchOnly,}) {
  return privateKeys(field0,field1);
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function()?  new,{TResult? Function( String field0)?  mnemonic,TResult? Function( String field0,  String field1)?  privateKeys,TResult? Function( String field0,  String field1)?  watchOnly,}) {
  return privateKeys?.call(field0,field1);
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function()?  new,{TResult Function( String field0)?  mnemonic,TResult Function( String field0,  String field1)?  privateKeys,TResult Function( String field0,  String field1)?  watchOnly,required TResult orElse(),}) {
  if (privateKeys != null) {
    return privateKeys(field0,field1);
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( WalletType_New value)  new,{required TResult Function( WalletType_Mnemonic value)  mnemonic,required TResult Function( WalletType_PrivateKeys value)  privateKeys,required TResult Function( WalletType_WatchOnly value)  watchOnly,}) {
  return privateKeys(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( WalletType_New value)?  new,{TResult? Function( WalletType_Mnemonic value)?  mnemonic,TResult? Function( WalletType_PrivateKeys value)?  privateKeys,TResult? Function( WalletType_WatchOnly value)?  watchOnly,}) {
  return privateKeys?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( WalletType_New value)?  new,{TResult Function( WalletType_Mnemonic value)?  mnemonic,TResult Function( WalletType_PrivateKeys value)?  privateKeys,TResult Function( WalletType_WatchOnly value)?  watchOnly,required TResult orElse(),}) {
  if (privateKeys != null) {
    return privateKeys(this);
  }
  return orElse();
}

}


abstract class WalletType_PrivateKeys extends WalletType {
  const factory WalletType_PrivateKeys(final  String field0, final  String field1) = _$WalletType_PrivateKeysImpl;
  const WalletType_PrivateKeys._(): super._();

  

 String get field0; String get field1;
@JsonKey(ignore: true)
_$$WalletType_PrivateKeysImplCopyWith<_$WalletType_PrivateKeysImpl> get copyWith => throw _privateConstructorUsedError;

}

/// @nodoc
abstract class _$$WalletType_WatchOnlyImplCopyWith<$Res>  {
  factory _$$WalletType_WatchOnlyImplCopyWith(_$WalletType_WatchOnlyImpl value, $Res Function(_$WalletType_WatchOnlyImpl) then) = __$$WalletType_WatchOnlyImplCopyWithImpl<$Res>;
@useResult
$Res call({
 String field0, String field1
});



}

/// @nodoc
class __$$WalletType_WatchOnlyImplCopyWithImpl<$Res> extends _$WalletTypeCopyWithImpl<$Res, _$WalletType_WatchOnlyImpl> implements _$$WalletType_WatchOnlyImplCopyWith<$Res> {
  __$$WalletType_WatchOnlyImplCopyWithImpl(_$WalletType_WatchOnlyImpl _value, $Res Function(_$WalletType_WatchOnlyImpl) _then)
      : super(_value, _then);


@pragma('vm:prefer-inline') @override $Res call({Object? field0 = null,Object? field1 = null,}) {
  return _then(_$WalletType_WatchOnlyImpl(
null == field0 ? _value.field0 : field0 // ignore: cast_nullable_to_non_nullable
as String,null == field1 ? _value.field1 : field1 // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class _$WalletType_WatchOnlyImpl extends WalletType_WatchOnly  {
  const _$WalletType_WatchOnlyImpl(this.field0, this.field1): super._();

  

@override final  String field0;
@override final  String field1;

@override
String toString() {
  return 'WalletType.watchOnly(field0: $field0, field1: $field1)';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$WalletType_WatchOnlyImpl&&(identical(other.field0, field0) || other.field0 == field0)&&(identical(other.field1, field1) || other.field1 == field1));
}


@override
int get hashCode => Object.hash(runtimeType,field0,field1);

@JsonKey(ignore: true)
@override
@pragma('vm:prefer-inline')
_$$WalletType_WatchOnlyImplCopyWith<_$WalletType_WatchOnlyImpl> get copyWith => __$$WalletType_WatchOnlyImplCopyWithImpl<_$WalletType_WatchOnlyImpl>(this, _$identity);

@override
@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function()  new,{required TResult Function( String field0)  mnemonic,required TResult Function( String field0,  String field1)  privateKeys,required TResult Function( String field0,  String field1)  watchOnly,}) {
  return watchOnly(field0,field1);
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function()?  new,{TResult? Function( String field0)?  mnemonic,TResult? Function( String field0,  String field1)?  privateKeys,TResult? Function( String field0,  String field1)?  watchOnly,}) {
  return watchOnly?.call(field0,field1);
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function()?  new,{TResult Function( String field0)?  mnemonic,TResult Function( String field0,  String field1)?  privateKeys,TResult Function( String field0,  String field1)?  watchOnly,required TResult orElse(),}) {
  if (watchOnly != null) {
    return watchOnly(field0,field1);
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( WalletType_New value)  new,{required TResult Function( WalletType_Mnemonic value)  mnemonic,required TResult Function( WalletType_PrivateKeys value)  privateKeys,required TResult Function( WalletType_WatchOnly value)  watchOnly,}) {
  return watchOnly(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( WalletType_New value)?  new,{TResult? Function( WalletType_Mnemonic value)?  mnemonic,TResult? Function( WalletType_PrivateKeys value)?  privateKeys,TResult? Function( WalletType_WatchOnly value)?  watchOnly,}) {
  return watchOnly?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( WalletType_New value)?  new,{TResult Function( WalletType_Mnemonic value)?  mnemonic,TResult Function( WalletType_PrivateKeys value)?  privateKeys,TResult Function( WalletType_WatchOnly value)?  watchOnly,required TResult orElse(),}) {
  if (watchOnly != null) {
    return watchOnly(this);
  }
  return orElse();
}

}


abstract class WalletType_WatchOnly extends WalletType {
  const factory WalletType_WatchOnly(final  String field0, final  String field1) = _$WalletType_WatchOnlyImpl;
  const WalletType_WatchOnly._(): super._();

  

 String get field0; String get field1;
@JsonKey(ignore: true)
_$$WalletType_WatchOnlyImplCopyWith<_$WalletType_WatchOnlyImpl> get copyWith => throw _privateConstructorUsedError;

}
